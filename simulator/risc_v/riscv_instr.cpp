/*
 * riscv_instr.cpp - instruction parser for risc_v
 * Copyright 2018 MIPT-MIPS
 */

#include "riscv_decoder.h"
#include "riscv_instr.h"

#include <func_sim/alu.h>
#include <func_sim/operation.h>

#include <iomanip>
#include <sstream>
#include <vector>

using Src = Reg;
using Dst = Reg;

struct RISCVAutogeneratedTableEntry
{
    std::string_view name;
    uint32 match;
    uint32 mask;

    bool check_mask( uint32 bytes) const noexcept
    {
        return ( bytes & mask) == match;
    }
};

#define PASTER(x,y) x ## y
#define EVALUATOR(x,y) PASTER(x,y)

#define DECLARE_INSN(name, match, mask) \
static const RISCVAutogeneratedTableEntry instr_ ## name = { #name, match, mask };
#include <riscv.opcode.gen.h>
#undef DECLARE_INSN

static const RISCVAutogeneratedTableEntry instr_invalid = { "unknown", 0x0, 0xffff };

template<Executable I>
static const RISCVTableEntry<I> invalid_instr =
    {'I', instr_invalid, ALU::unknown_instruction<I>, OUT_ARITHM, ' ', Imm::NO, { Src::ZERO, Src::ZERO }, { Dst::ZERO }, 0, 32 | 64 | 128};

template<Executable I>
struct RISCVTableEntry
{
    using Execute = void (*)(I*);

    char subset = 'I';
    RISCVAutogeneratedTableEntry entry = instr_invalid;
    Execute function = ALU::unknown_instruction<I>;
    OperationType type = OUT_ARITHM;
    char immediate_type = ' ';
    Imm immediate_print_type = Imm::NO;
    std::vector<Src::Type> src = { Src::ZERO, Src::ZERO };
    std::vector<Dst::Type> dst = { Dst::ZERO };
    uint32 mem_size = 0;
    uint32 bit_width = 32 | 64 | 128;

    bool check_print_dst( size_t dst_id) const
    {
        Dst::Type reg = dst.at( dst_id);
        return reg != Reg::ZERO
            && reg != Reg::MEPC
            && reg != Reg::SEPC
            && reg != Reg::RA;
    }

    bool check_print_src( size_t src_id) const
    {
        Src::Type reg = src.at( src_id);

        if ( subset == 'C' && reg == dst.at( 0))
            return false;

        return reg != Reg::ZERO
            && reg != Reg::SEPC
            && reg != Reg::MEPC
            && reg != Reg::CSR;
    }

    size_t num_dst() const { return dst.size(); }
    size_t num_src() const { return src.size(); }

    bool check_mask_and_type( uint32 bytes) const noexcept
    {
        return entry.check_mask( bytes) && (bitwidth<typename I::RegisterUInt> & bit_width) != 0;
    }
};

template<Executable I>
static const std::vector<RISCVTableEntry<I>> cmd_desc =
{
    /*-------------- I --------------*/
    { }, // invalid instruction
    {'I', instr_lui,   ALU::upper_immediate<12, I>, OUT_ARITHM, 'U', Imm::LOGIC, { Src::ZERO, Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_auipc, ALU::auipc<I>,               OUT_ARITHM, 'U', Imm::LOGIC, { Src::ZERO, Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    // Jumps
    {'I', instr_jal,        ALU::jump_and_link<I, ALU::j>,          OUT_J_JUMP, 'J', Imm::ARITH, { Src::ZERO, Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_jalr,       ALU::jump_and_link<I, ALU::riscv_jr>,   OUT_R_JUMP, 'I', Imm::LOGIC, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    // Branches
    {'I', instr_beq,        ALU::branch<I, &I::eq>,    OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    {'I', instr_bne,        ALU::branch<I, &I::ne>,    OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    {'I', instr_blt,        ALU::branch<I, &I::lt>,    OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    {'I', instr_bge,        ALU::branch<I, &I::ge>,    OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    {'I', instr_bltu,       ALU::branch<I, &I::ltu>,   OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    {'I', instr_bgeu,       ALU::branch<I, &I::geu>,   OUT_BRANCH, 'B', Imm::ARITH, { Src::RS1,  Src::RS2 },  { Dst::ZERO }, 0, 32 | 64 | 128},
    // Loads
    {'I', instr_lb,         ALU::addr<I>,   OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 1, 32 | 64 | 128},
    {'I', instr_lh,         ALU::addr<I>,   OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 2, 32 | 64 | 128},
    {'I', instr_lw,         ALU::addr<I>,   OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 4, 32 | 64 | 128},
    {'I', instr_ld,         ALU::addr<I>,   OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 8,      64 | 128},
    // Unsigned loads
    {'I', instr_lbu,        ALU::addr<I>,   OUT_LOADU,  'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 1, 32 | 64 | 128},
    {'I', instr_lhu,        ALU::addr<I>,   OUT_LOADU,  'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 2, 32 | 64 | 128},
    {'I', instr_lwu,        ALU::addr<I>,   OUT_LOADU,  'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::RD }, 4, 32 | 64 | 128},
    // Stores
    {'I', instr_sb,         ALU::store_addr<I>,  OUT_STORE,  'S', Imm::ADDR,  { Src::RS1,  Src::RS2 },  { Dst::ZERO },          1, 32 | 64 | 128},
    {'I', instr_sh,         ALU::store_addr<I>,  OUT_STORE,  'S', Imm::ADDR,  { Src::RS1,  Src::RS2 },  { Dst::ZERO },          2, 32 | 64 | 128},
    {'I', instr_sw,         ALU::store_addr<I>,  OUT_STORE,  'S', Imm::ADDR,  { Src::RS1,  Src::RS2 },  { Dst::ZERO },          4, 32 | 64 | 128},
    {'I', instr_sd,         ALU::store_addr<I>,  OUT_STORE,  'S', Imm::ADDR,  { Src::RS1,  Src::RS2 },  { Dst::ZERO },          8,      64 | 128},
    // Immediate arithmetics
    {'I', instr_addi,       ALU::riscv_addition_imm<I>,            OUT_ARITHM, 'I', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_slli,       ALU::sll<I, typename I::RegisterUInt>, OUT_ARITHM, '7', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_srli,       ALU::srl<I, typename I::RegisterUInt>, OUT_ARITHM, '7', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_srai,       ALU::sra<I, typename I::RegisterUInt>, OUT_ARITHM, '7', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 32 | 64 | 128},
    // Immediate arithmetics - RV64 specific
    {'I', instr_addiw,      ALU::riscv_addition_imm<I, uint32>,  OUT_ARITHM, 'I', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 64 | 128},
    {'I', instr_slliw,      ALU::sll<I, uint32>,                 OUT_ARITHM, '5', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 64 | 128},
    {'I', instr_srliw,      ALU::srl<I, uint32>,                 OUT_ARITHM, '5', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 64 | 128},
    {'I', instr_sraiw,      ALU::sra<I, uint32>,                 OUT_ARITHM, '5', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 64 | 128},
    // Immediate arithmetics - RV128 specific
    {'I', instr_addid,      ALU::riscv_addition_imm<I, uint64>,  OUT_ARITHM, 'I', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 128},
    {'I', instr_sllid,      ALU::sll<I, uint64>,                 OUT_ARITHM, '6', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 128},
    {'I', instr_srlid,      ALU::srl<I, uint64>,                 OUT_ARITHM, '6', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 128},
    {'I', instr_sraid,      ALU::sra<I, uint64>,                 OUT_ARITHM, '6', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD }, 0, 128},
    // Immediate logic and comparison
    {'I', instr_slti,       ALU::set<I, &I::lti>,   OUT_ARITHM, 'I', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD },            0, 32 | 64 | 128},
    {'I', instr_sltiu,      ALU::set<I, &I::ltiu>,  OUT_ARITHM, 'I', Imm::ARITH, { Src::RS1,  Src::ZERO }, { Dst::RD },            0, 32 | 64 | 128},
    {'I', instr_xori,       ALU::xori<I>,           OUT_ARITHM, 'I', Imm::LOGIC, { Src::RS1,  Src::ZERO }, { Dst::RD },            0, 32 | 64 | 128},
    {'I', instr_ori,        ALU::ori<I>,            OUT_ARITHM, 'I', Imm::LOGIC, { Src::RS1,  Src::ZERO }, { Dst::RD },            0, 32 | 64 | 128},
    {'I', instr_andi,       ALU::andi<I>,           OUT_ARITHM, 'I', Imm::LOGIC, { Src::RS1,  Src::ZERO }, { Dst::RD },            0, 32 | 64 | 128},
    // Register-register arithmetics
    {'I', instr_add,        ALU::riscv_addition<I, typename I::RegisterUInt>   , OUT_ARITHM, ' ', Imm::NO, { Src::RS1,  Src::RS2 },  { Dst::RD },    0, 32 | 64 | 128},
    {'I', instr_sub,        ALU::riscv_subtraction<I, typename I::RegisterUInt>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_sll,        ALU::sllv<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD },           0, 32 | 64 | 128},
    {'I', instr_sra,        ALU::srav<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD },           0, 32 | 64 | 128},
    {'I', instr_srl,        ALU::srlv<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD },           0, 32 | 64 | 128},
    // Regist-register arithmetics - RV64 specific
    {'I', instr_addw,       ALU::riscv_addition<I, uint32>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0,      64 | 128},
    {'I', instr_subw,       ALU::riscv_subtraction<I, uint32>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0,      64 | 128},
    {'I', instr_sllw,       ALU::sllv<I, uint32>,              OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0,      64 | 128},
    {'I', instr_sraw,       ALU::srav<I, uint32>,              OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0,      64 | 128},
    {'I', instr_srlw,       ALU::srlv<I, uint32>,              OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0,      64 | 128},
    // Register-register logic and comparison
    {'I', instr_slt,        ALU::set<I, &I::lt>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_sltu,       ALU::set<I, &I::ltu>,   OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_and,        ALU::andv<I>,           OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_xor,        ALU::xorv<I>,           OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'I', instr_or,         ALU::orv<I>,            OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    // CSR
    {'I', instr_ecall,      ALU::syscall<I>,    OUT_TRAP,   ' ', Imm::NO,    { Src::ZERO, Src::ZERO }, { Dst::ZERO },          0, 32 | 64 | 128},
    {'I', instr_ebreak,     ALU::breakpoint<I>, OUT_TRAP,   ' ', Imm::NO,    { Src::ZERO, Src::ZERO }, { Dst::ZERO },          0, 32 | 64 | 128},
    {'I', instr_sret,       ALU::jump_and_link<I, ALU::riscv_jr>,   OUT_R_JUMP, ' ', Imm::NO,    { Src::SEPC, Src::ZERO }, { Dst::ZERO },          0, 32 | 64 | 128},
    {'I', instr_mret,       ALU::jump_and_link<I, ALU::riscv_jr>,   OUT_R_JUMP, ' ', Imm::NO,    { Src::MEPC, Src::ZERO }, { Dst::ZERO },          0, 32 | 64 | 128},
    {'I', instr_csrrw,      ALU::csrrw<I>,  OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::CSR },  { Dst::CSR, Dst::RD },  0, 32 | 64 | 128},
    {'I', instr_csrrs,      ALU::csrrs<I>,  OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::CSR },  { Dst::CSR, Dst::RD },  0, 32 | 64 | 128},
    {'I', instr_csrrwi,     ALU::csrrwi<I>, OUT_ARITHM, 'C', Imm::LOGIC, { Src::ZERO, Src::CSR },  { Dst::CSR, Dst::RD },  0, 32 | 64 | 128},
    {'I', instr_fence,      ALU::addr<I>,  OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::ZERO },           0, 32 | 64 | 128},
    {'I', instr_fence_i,    ALU::addr<I>,  OUT_LOAD,   'I', Imm::ADDR,  { Src::RS1,  Src::ZERO }, { Dst::ZERO },           0, 32 | 64 | 128},
    /*-------------- M --------------*/
    // Multiplication
    {'M', instr_mul,    RISCVMultALU::mult_l<I>,    OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_mulh,   RISCVMultALU::mult_h_ss<I>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_mulhsu, RISCVMultALU::mult_h_su<I>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_mulhu,  RISCVMultALU::mult_h_uu<I>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    // Division
    {'M', instr_div,  RISCVMultALU::div<sign_t<typename I::RegisterUInt>, I>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_divu, RISCVMultALU::div<typename I::RegisterUInt, I>,         OUT_ARITHM, ' ', Imm::NO, { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_rem,  RISCVMultALU::rem<sign_t<typename I::RegisterUInt>, I>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'M', instr_remu, RISCVMultALU::rem<typename I::RegisterUInt, I>,         OUT_ARITHM, ' ', Imm::NO, { Src::RS1,  Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    /*-------------- C --------------*/
    // Breakpoint
    {'C', instr_c_ebreak,   ALU::breakpoint<I>, OUT_BREAK,  ' ',                   Imm::NO,       { Src::ZERO,     Src::ZERO },     { Dst::ZERO },     0, 32 | 64 | 128},
    // NOP
    {'C', instr_c_nop,      ALU::orv<I>,    OUT_ARITHM, ' ',                       Imm::NO,       { Src::ZERO,     Src::ZERO },     { Dst::ZERO },     0, 32 | 64 | 128},
    // Jumps
    {'C', instr_c_j,    ALU::jump_and_link<I, ALU::j>,        OUT_BRANCH, ImmediateType::C_J, Imm::JUMP_REL, { Src::ZERO, Src::ZERO }, { Dst::ZERO },     0, 32 | 64 | 128},
    {'C', instr_c_jal,  ALU::jump_and_link<I, ALU::j>,        OUT_BRANCH, ImmediateType::C_J, Imm::JUMP_REL, { Src::ZERO, Src::ZERO }, { Dst::RA },       0, 32           },
    {'C', instr_c_jr,   ALU::jump_and_link<I, ALU::riscv_jr>, OUT_BRANCH, ' ',          Imm::NO,       { Src::RD,   Src::ZERO }, { Dst::ZERO },     0, 32 | 64 | 128},
    {'C', instr_c_jalr, ALU::jump_and_link<I, ALU::riscv_jr>, OUT_BRANCH, ' ',          Imm::NO,       { Src::RD,   Src::ZERO }, { Dst::RA },       0, 32 | 64 | 128},
    // Branches
    {'C', instr_c_beqz,     ALU::branch<I, &I::eq>, OUT_BRANCH, ImmediateType::C_B, Imm::ARITH,    { Src::RS1_3BIT, Src::ZERO },     { Dst::ZERO },     0, 32 | 64 | 128},
    {'C', instr_c_bnez,     ALU::branch<I, &I::ne>, OUT_BRANCH, ImmediateType::C_B, Imm::ARITH,    { Src::RS1_3BIT, Src::ZERO },     { Dst::ZERO },     0, 32 | 64 | 128},
    // Loads
    {'C', instr_c_lwsp,     ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LWSP,     Imm::ADDR,     { Src::SP,       Src::ZERO },     { Dst::RD },       4, 32 | 64 | 128},
    {'C', instr_c_ldsp,     ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LDSP,     Imm::ADDR,     { Src::SP,       Src::ZERO },     { Dst::RD },       8,      64 | 128},
    {'C', instr_c_lqsp,     ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LQSP,     Imm::ADDR,     { Src::SP,       Src::ZERO },     { Dst::RD },       16,          128},
    {'C', instr_c_lw,       ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LW,       Imm::ADDR,     { Src::RS1_3BIT, Src::ZERO },     { Dst::RD_3BIT },  4, 32 | 64 | 128},
    {'C', instr_c_ld,       ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LD,       Imm::ADDR,     { Src::RS1_3BIT, Src::ZERO },     { Dst::RD_3BIT },  8,      64 | 128},
    {'C', instr_c_lq,       ALU::addr<I>,   OUT_LOAD,   ImmediateType::C_LQ,       Imm::ADDR,     { Src::RS1_3BIT, Src::ZERO },     { Dst::RD_3BIT },  16,          128},
    // Stores
    {'C', instr_c_swsp,     ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_SWSP,     Imm::ADDR,     { Src::SP,       Src::RS2_CMP },  { Dst::ZERO },     4, 32 | 64 | 128},
    {'C', instr_c_sdsp,     ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_SDSP,     Imm::ADDR,     { Src::SP,       Src::RS2_CMP },  { Dst::ZERO },     8,      64 | 128},
    {'C', instr_c_sqsp,     ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_SQSP,     Imm::ADDR,     { Src::SP,       Src::RS2_CMP },  { Dst::ZERO },     16,          128},
    {'C', instr_c_sw,       ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_LW,       Imm::ADDR,     { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::ZERO },     4, 32 | 64 | 128},
    {'C', instr_c_sd,       ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_LD,       Imm::ADDR,     { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::ZERO },     8,      64 | 128},
    {'C', instr_c_sq,       ALU::store_addr<I>,  OUT_STORE,  ImmediateType::C_LQ,       Imm::ADDR,     { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::ZERO },     16,          128},
    // Immediate arithmetics
    {'C', instr_c_addi16sp, ALU::riscv_addition_imm<I>,   OUT_ARITHM, ImmediateType::C_ADDI16SP, Imm::ARITH,   { Src::SP,       Src::ZERO }, { Dst::SP },       0, 32 | 64 | 128},
    {'C', instr_c_addi,     ALU::riscv_addition_imm<I>,   OUT_ARITHM, ImmediateType::C_I,        Imm::ARITH,   { Src::RD,       Src::ZERO }, { Dst::RD },       0, 32 | 64 | 128},
    {'C', instr_c_srli,     ALU::srl<I, typename I::RegisterUInt>, OUT_ARITHM, ImmediateType::C_S, Imm::ARITH, { Src::RS1_3BIT, Src::ZERO }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    {'C', instr_c_srai,     ALU::sra<I, typename I::RegisterUInt>, OUT_ARITHM, ImmediateType::C_S, Imm::ARITH, { Src::RS1_3BIT, Src::ZERO }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    {'C', instr_c_slli,     ALU::sll<I, typename I::RegisterUInt>, OUT_ARITHM, ImmediateType::C_S, Imm::ARITH, { Src::RD,       Src::ZERO }, { Dst::RD },       0, 32 | 64 | 128},
    {'C', instr_c_addi4spn, ALU::riscv_addition_imm<I>,          OUT_ARITHM, ImmediateType::C_ADDI4SPN, Imm::ARITH, { Src::SP, Src::ZERO }, { Dst::RD_3BIT },   0, 32 | 64      },
    {'C', instr_c_addiw,    ALU::riscv_addition_imm<I, uint32>,  OUT_ARITHM, ImmediateType::C_I,        Imm::ARITH, { Src::RD, Src::ZERO }, { Dst::RD },        0,      64 | 128},
    // Constant-Generation
    {'C', instr_c_li,       ALU::riscv_addition_imm<I>,  OUT_ARITHM, ImmediateType::C_I,        Imm::ARITH,    { Src::ZERO,     Src::ZERO },     { Dst::RD },       0, 32 | 64 | 128},
    {'C', instr_c_lui,      ALU::upper_immediate<12, I>, OUT_ARITHM, ImmediateType::C_I,        Imm::LOGIC,    { Src::ZERO,     Src::ZERO },     { Dst::RD },       0, 32 | 64 | 128},
    // Immediate logic and comparison
    {'C', instr_c_andi,     ALU::andi<I>,   OUT_ARITHM, ImmediateType::C_I,        Imm::ARITH,    { Src::RS1_3BIT, Src::ZERO },     { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    // Register-register arithmetics
    {'C', instr_c_add,      ALU::riscv_addition<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO, { Src::RD,       Src::RS2_CMP },  { Dst::RD },       0, 32 | 64 | 128},
    {'C', instr_c_sub,      ALU::riscv_subtraction<I, typename I::RegisterUInt>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    // Register-register - RV64 specific
    {'C', instr_c_addw,     ALU::riscv_addition<I, uint32>,    OUT_ARITHM, ' ', Imm::NO,       { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0,      64 | 128},
    {'C', instr_c_subw,     ALU::riscv_subtraction<I, uint32>, OUT_ARITHM, ' ', Imm::NO,       { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0,      64 | 128},
    // Register-register logic
    {'C', instr_c_mv,       ALU::orv<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::ZERO,     Src::RS2_CMP },  { Dst::RD },       0, 32 | 64 | 128},
    {'C', instr_c_xor,      ALU::xorv<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    {'C', instr_c_or,       ALU::orv<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    {'C', instr_c_and,      ALU::andv<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1_3BIT, Src::RS2_3BIT }, { Dst::RS1_3BIT }, 0, 32 | 64 | 128},
    /*-------------- B --------------*/
    // Bit manipulation
    {'B', instr_slo,        ALU::slo<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64 },
    {'B', instr_sro,        ALU::sro<I, typename I::RegisterUInt>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64 },
    {'B', instr_sloi,       ALU::sloi<I, typename I::RegisterUInt>,   OUT_ARITHM, '7', Imm::ARITH, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64   },
    {'B', instr_orn,        ALU::orn<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_binv,       ALU::binv<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_bext,       ALU::bext<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_pack,       ALU::pack<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_packu,      ALU::packu<I>,  OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_xnor,       ALU::xnor<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_bfp,        ALU::bfp<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_grev,       ALU::grev<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_cpop,       ALU::pcnt<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_rol,        ALU::rol<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_ror,        ALU::ror<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_clmul,      ALU::clmul<I>,  OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_max,        ALU::max<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_maxu,       ALU::maxu<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_min,        ALU::min<I>,    OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_minu,       ALU::minu<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_gorc,       ALU::gorc<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_orc_b,      ALU::orc_b<I>,  OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64      },
    {'B', instr_unshfl,     ALU::unshfl<I>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64 | 128},
    {'B', instr_rori,       ALU::rori<I>,   OUT_ARITHM, '7', Imm::ARITH, { Src::RS1, Src::ZERO },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_shfl,       ALU::shfl<I>,   OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64      },
    {'B', instr_sroi,       ALU::sroi<I>,   OUT_ARITHM, '7', Imm::ARITH, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64   },
    {'B', instr_add_uw,     ALU::add_uw<I>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1, Src::RS2 },  { Dst::RD }, 0,      64   },
    {'B', instr_bclr,       ALU::bclr<I>,   OUT_ARITHM, ' ', Imm::NO,    { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64   },
    {'B', instr_bclri,      ALU::bclri<I>,  OUT_ARITHM, '7', Imm::ARITH, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64   },
    {'B', instr_bseti,      ALU::bseti<I>,  OUT_ARITHM, '7', Imm::ARITH, { Src::RS1, Src::ZERO},  { Dst::RD},  0, 32 | 64   },
    {'B', instr_bset,       ALU::bset<I>,   OUT_ARITHM, ' ', Imm::NO,    { Src::RS1, Src::RS2 },  { Dst::RD }, 0, 32 | 64   },
    {'B', instr_sext_b,     ALU::sext_b<I>, OUT_ARITHM, ' ', Imm::NO,    { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64   },
    {'B', instr_clz,        ALU::clz<I, typename I::RegisterUInt>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64 },
    {'B', instr_ctz,        ALU::ctz<I, typename I::RegisterUInt>, OUT_ARITHM, ' ', Imm::NO, { Src::RS1, Src::ZERO }, { Dst::RD }, 0, 32 | 64 }
};


template<Executable I>
const auto& find_entry( uint32 bytes)
{
    for ( const auto& e : cmd_desc<I>)
        if ( e.check_mask_and_type( bytes))
            return e;

    return invalid_instr<I>;
}

template<Executable I>
const auto& find_entry( std::string_view name)
{
    for ( const auto& e : cmd_desc<I>)
        if ( e.entry.name == name)
            return e;

    return invalid_instr<I>;
}

template<Unsigned T>
RISCVInstr<T>::RISCVInstr( uint32 bytes, Addr PC)
    : BaseInstruction<T, RISCVRegister>( PC, PC + 4), instr( bytes)
{
    const auto& entry = find_entry<MyDatapath>( bytes);
    init( entry);

    RISCVInstrDecoder decoder( bytes);
    this->v_imm = RISCVInstrDecoder::get_immediate<T>( entry.immediate_type, decoder.get_immediate_value( entry.immediate_type));

    for ( size_t i = 0; i < entry.num_src(); i++)
        this->src.at( i) = decoder.get_register( entry.src.at( i));
    for ( size_t i = 0; i < entry.num_dst(); i++)
        this->dst.at( i) = decoder.get_register( entry.dst.at( i));

    init_target();
}


template<Unsigned T>
RISCVInstr<T>::RISCVInstr( std::string_view name, uint32 immediate, Addr PC)
    : BaseInstruction<T, RISCVRegister>( PC, PC + 4)
{
    const auto& entry = find_entry<MyDatapath>( name);
    init( entry);

    this->v_imm = RISCVInstrDecoder::get_immediate<T>( entry.immediate_type, immediate);
    init_target();
}

template<Unsigned T>
void RISCVInstr<T>::init_target()
{
    if ( this->is_branch())
        this->target = this->PC + sign_extension<12>( narrow_cast<Addr>( this->v_imm));
    else if ( this->is_direct_jump())
        this->target = this->PC + sign_extension<20>( narrow_cast<Addr>( this->v_imm));
}

template<Unsigned T>
void RISCVInstr<T>::init( const RISCVTableEntry<MyDatapath>& entry)
{
    if (entry.subset == 'C')
        this->new_PC = this->PC + 2;

    this->imm_print_type = entry.immediate_print_type;
    this->mem_size = entry.mem_size;
    this->set_type( entry.type);
    this->executor = entry.function;
    this->opname = entry.entry.name;

    for ( size_t i = 0; i < entry.num_dst(); i++)
        if ( entry.check_print_dst( i))
            this->print_dst.set( i);
    for ( size_t i = 0; i < entry.num_src(); i++)
        if ( entry.check_print_src( i))
            this->print_src.set( i);
}

template<Unsigned T>
std::string RISCVInstr<T>::get_disasm() const
{
    return this->generate_disasm();
}

template<Unsigned R>
std::string RISCVInstr<R>::string_dump() const
{
    std::ostringstream oss;
    this->dump_content( oss, get_disasm());
    return oss.str();
}

template<Unsigned R>
std::string RISCVInstr<R>::bytes_dump() const
{
     std::ostringstream oss;
     oss << "Bytes:" << std::hex;
     for ( const auto& b : unpack_array<std::endian::little>( instr))
         oss << " 0x" << std::setfill( '0') << std::setw( 2) << static_cast<uint16>( b);
     return oss.str();
}

template class RISCVInstr<uint32>;
template class RISCVInstr<uint64>;
template class RISCVInstr<uint128>;
